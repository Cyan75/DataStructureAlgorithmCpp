## 3. Arrays, Linked Lists, and Recursion

### 1. Arrays

1. Storing Game Entries in an Array
   * the maximum number of scores may vary from instance to instance
   * **insertion** :  add a game enstry `e` to the highest scores. entry exceeding `maxEntries` will be removed, lower scores are shifted to the right.
   * **remove** : remove and return the game entry `e` at index `i` in the `entries` array, higher scores are shifter to the left
```c++
#include <string>

//------header file
class GameEntry
{
public:
    GameEntry(const std::string &n = "", int s = 0);
    std::string getName() const;
    int getScore() const;

private:
    std::string name;
    int score;
};
//-----------

//------implementation file
GameEntry::GameEntry(const std::string &n, int s) : name(n), score(s) {}
std::string GameEntry::getName() const { return name; }
int GameEntry::getScore() const { return score; }
//------

//-----header file
class Scores
{
public:
    Scores(int maxEnt = 10);
    ~Scores();
    void add(const GameEntry &e);
    GameEntry remove(int i) { throw(IndexOutOfBounds); }

private:
    int maxEntries;     //desired maximum entries
    int numEntries;     //actual number of entries
    GameEntry *entries; //array of game entries
};
//-----------

//------implementation file
Scores::Scores(int maxEnt)
{
    maxEntries = maxEnt;
    entries = new GameEntry[maxEntries];
    numEntries = 0; //initially no elements
}
Scores::~Scores()
{
    delete[] entries;
}
void Scores::add(const GameEntry &e) //add an game entry object
{
    int newScore = e.getScore();
    if (numEntries == maxEntries) //the array is full
    {
        if (newScore <= entries[maxEntries - 1].getScore()) //smaller than the lowest score of the original standing
        {
            return;
        }
        else
            numEntries++;
        int i = numEntries - 2; //the nest lowest score
        while (i >= 0 && newScore > entries[i].getScore())
        {
            entries[i + 1] = entries[i]; //shift to the right
            i--;
        }
        entries[i + 1] = e;
    }
}
GameEntry Scores::remove(int i) throw(IndexOutOfBounds)
{
    if ((i < 0) || (i > numEntries))
        throw IndexOutOfBounds("Invalid Index");
    GameEntry e = entries[i];
    for (int j = i + 1; j < numEntries; j++)
        entries[j - 1] = entries[j];
    numEntries--;
    return e;
}
//-----------
```

2. Sorting an Array  
   1. Insertion Sort
      * input is an array A of n comparable elements
      * output is the arrya A with elements rearranged 
        * for i ⟵ 1 to `n-1` do
          * insert A[i] at its proper location in A[0], A,[1], ...
        * current ⟵ A[i]
        * j ⟵ `i-1`
        * while j≥0 and **A[j]>current** do
          * A[j+1] ⟵ A[j]
          * j ⟵ j-1
          * A[j+1] ⟵ current
    ```c++
    void insertionSort(char * A, int n){//char * A : pointer to the first element of the array
        for (int i = 1; i < n; ++i){
            char current A[i];
            int j = i-1;
            while((j >= 0) && (A[j] > current)){
                A[j+1] = A[j];
                j--;
            }
            A[j+1] = current;
        }
    }
    ```
 3. Two-Dimensional Array and Positional Games
    * an array of arrays : a matrix
    * dynamic allocation of matrices: in case the size of a matrix is not pre-definable
    ```c++
    //allocation
    int **M = new int* [n]; //a pointer to a pointer//an array of row pointers
    for(int i = 0; i < n; ++i){
        M[i] = new int[m];//the i-th row
    }

    //deallocation
    for(int i = 0; i < n; ++i){
        delete[] M[i]; //delete the i-th row
    }
    delete[] M;// delete the array of row pointers
    ```
    * **STL Vector**
    ```c++
    vector< vector<int> > M(n, vector<int>(m));
    cout << M[i][j] <<endl;
    ```

### 2. Singly Linked Lists
1. Linked Lists : easy adding and removing
2. Implementing Singly Linked Lists
   1. Add and remove an element 
  ```c++
  class StringNode{
      private:
      string elem;  //element value
      StringNode* next; //next item in the list

      friend class StringLinkedList;    //access to StringLinked List
  };

  class StringLinkedList{   // alinked list of strings
      public:
      StringLinkedList();
      ~StringLinkedList();
      bool empty() const;   //is empty
      const string& front() const;  //get front element
      void addFront(const string& e);   //add to front of the list
      void removeFront();   //remove front item list
      private:
      StringNode * head;    //pointer to the head of list
  };
    StringLinkedList::StringLinkedList() : head(NULL){}
    StringLinkedList::~StringLinkedList(){
        while(!empty()){
            removeFront(); //destroys the whole list
        }
    }
    bool StringLinkedList::empty() const{
        return head == NULL;
    }
    const string& front() const{ 
        return head->elem;
    }
    void addFront(const string& e){
        StringNode* v = new StringNode;
        v->elem = e;
        v->next = head;
        head = v;
    }
    void StringLinkedList::removeFront(){
    StringNode* old = head;
    head = old->next;
    delete old;
  }
 
  ```
  ### 3. Doubly Linked Lists